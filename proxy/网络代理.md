什么是网络代理？
1、用户通过代理请求信息
2、请求通过网络dialing完成转发到目标服务器
3、目标服务器响应后再通过代理传回给用户

网络代理 和 网络转发的区别是什么？

网络代理：用户直接连接代理服务器，由代理服务器连接后端服务。
网络转发：是路由器对报文的转发操作，中间也可能对数据包进行修改

网络代理的类型？

    1、正向代理
        是一个客户端的代理技术，帮助客户端访问无法访问的服务资源，可以隐藏用户的真实ip，比如浏览器web代理、vpn
    2、反向代理
        是一个服务端的代理技术，帮助服务器做负载均衡、缓存、提供安全校验等，可以隐藏服务器真实ip
        比如LVS\nginx proxy_pass等


实现一个web浏览器代理：

    正向代理：
    1、代理接收客户端请求、复制原请求对象、并根据数据配置请求各种参数
    2、把请求发送的目标服务器，并接收服务器的返回数据
    3、代理服务器做一些处理，然后返回给客户端

用户发来请求-》代理服务器监听中-》上游tcp连接-》回调方法-》拷贝数据-》请求下游服务transport RoundTrip-》回写上游数据

实现一个反向代理：

[简版的http反向代理]

    这功能比较复杂，先实现一个简版的http反向代理
    1、代理接收客户端请求，更改请求结构体
    2、通过一定的负载均衡算法获取下游服务地址
    3、把请求发送到下游服务器，并获取返回内容
    4、对返回内容做一些处理，饭后返会给客户端

[完整版http代理]
简版的http代理，不具备哪些功能？

    1、错误回调及错误日志处理
    2、更改dialing返回内容
    3、负载均衡
    4、url重写
    5、限流、熔断、降级
    6、数据统计
    7、权限验证
    
 http代理大纲：用ReverseProxy实现一个http代理

    1、ReverseProxy的功能点
    2、ReverseProxy演示
    3、ReverseProxy源码分析
    4、扩展ReverseProxy功能：
        a、四种负载均衡类型的实现及接口封装；
        b、扩展中间件的支持（限流、熔断、权限、数据统计）

ReverseProxy的功能点：

    1、可以更改内容
    2、错误信息回调
    3、支持自定义负载均衡
    4、url重写功能
    5、连接池功能
    6、支持websocket服务（独立章节介绍）
    7、支持https代理（独立章节介绍）

1、ReverseProxy实现了ServeHTTP()，即实现了Handler接口 :


2、ReverseProxy更改内容的支持：demo/proxy/reverse_proxy_step


    type ReverseProxy struct{
        // 控制器必须是一个函数，此函数可以对请求的信息进行修改
        Director func(*http.Request)、
        // 连接池，如果是nil，则使用http.DefaultTransport
        Transport http.RoundTripper
        // 刷新到客户端的刷新间隔
        FlushInterval time.Duration
        // 错误记录器，用于记录错误
        ErrorLog *log.Logger
        // 顶一个一个缓冲池，在复制http响应时使用，可以提高请求效率
        BufferPool BufferPool
        // 修改response，可以返回error，来主动的触发ErrorHandler
        ModifyResponse func(*http.Response)error
        // 错误处理回调函数，如果是nil，则遇到错误会显示502.连接池的错误也会影响到ErrorHandler的调用
        ErrorHandler func(http.ResponseWriter,*http.Request)
    }

    
        func NewLoadBalanceReverseProxy(c *gin.Context, lb load_balance.LoadBalance, trans *http.Transport) *httputil.ReverseProxy {
        //请求协调者
        director := func(req *http.Request) {
            nextAddr, err := lb.Get(req.URL.String())
            //todo 优化点3
            if err != nil || nextAddr=="" {
                panic("get next addr fail")
            }
            target, err := url.Parse(nextAddr)
            if err != nil {
                panic(err)
            }
            targetQuery := target.RawQuery
            req.URL.Scheme = target.Scheme
            req.URL.Host = target.Host
            req.URL.Path = singleJoiningSlash(target.Path, req.URL.Path)
            req.Host = target.Host
            if targetQuery == "" || req.URL.RawQuery == "" {
                req.URL.RawQuery = targetQuery + req.URL.RawQuery
            } else {
                req.URL.RawQuery = targetQuery + "&" + req.URL.RawQuery
            }
            if _, ok := req.Header["User-Agent"]; !ok {
                req.Header.Set("User-Agent", "user-agent")
            }
        }
    
        //更改内容
        modifyFunc := func(resp *http.Response) error {
            // 并不是所有情况都需要对response进行重写
            if strings.Contains(resp.Header.Get("Connection"), "Upgrade") {
                return nil
            }
    
            //todo 优化点2
            //var payload []byte
            //var readErr error
            //
            //if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
            //	gr, err := gzip.NewReader(resp.Body)
            //	if err != nil {
            //		return err
            //	}
            //	payload, readErr = ioutil.ReadAll(gr)
            //	resp.Header.Del("Content-Encoding")
            //} else {
            //	payload, readErr = ioutil.ReadAll(resp.Body)
            //}
            //if readErr != nil {
            //	return readErr
            //}
            //
            //c.Set("status_code", resp.StatusCode)
            //c.Set("payload", payload)
            
            //resp.Body = ioutil.NopCloser(bytes.NewBuffer(payload))
            //resp.ContentLength = int64(len(payload))
            //resp.Header.Set("Content-Length", strconv.FormatInt(int64(len(payload)), 10))
            return nil
        }
    
        //错误回调 ：关闭real_server时测试，错误回调
        //范围：transport.RoundTrip发生的错误、以及ModifyResponse发生的错误
        errFunc := func(w http.ResponseWriter, r *http.Request, err error) {
            middleware.ResponseError(c,999,err)
        }

        return &httputil.ReverseProxy{Director: director, ModifyResponse: modifyFunc, ErrorHandler: errFunc}
    }
    
    func singleJoiningSlash(a, b string) string {
        aslash := strings.HasSuffix(a, "/")
        bslash := strings.HasPrefix(b, "/")
        switch {
        case aslash && bslash:
             return a + b[1:]
        case !aslash && !bslash:
            return a + "/" + b
        }
        return a + b
    }

3、header头 Connection

    1、标记请求发起方与第一代理的状态（如果请求经过了多个代理，第一个就是第一代理，每个代理都需要转发，客户端与第一代理建立三次握手，
        第一代理一边接收，一边将接收到的消息发送到第二代理，第一代理和第二代理也需要建立socket连接，与最终服务器也需要建立socket，
        客户端不知道服务器端的ip）

    2、决定当前事务完成后，是否会关闭网络

        Connection：keep-alive不关闭网络，复用连接；浏览器请求都是这个方式
        Connection：close 关闭网络，如果是col都是这个方式
        Connection：Upgrade 协议升级，一般websocket、http2都会使用这个方式

4、TE 是request_header（请求头），表示希望使用的传输编码类型
    如：TE:trailers，deflate；q0.5，表示期望在采用分块阐述编码响应中接收挂载字段，zilb编码，0。5优先级排序

5、 Trailer是response header（返回头），允许发送方在消息后边添加额外的元信息
    如：Trailer：Expires，表示超时，Expires将出现在分块信息的结尾
    

第一代理去除标准的逐段传输头（hop-by-hop）：第一代理在转发消息的时候需要把逐段传输头去掉，因为这些消息头只标记了和第一代理之间的消息传递细节，
    再向下游传输的时候，这些头是没有用的。并且状态已经失效了

    1、逐段传输头需要在Connection中列出
    2、第一代理需要知道是去处理它，而不是去转发它（比如协议升级，客户端和第一代理之间需要，但是第一代理和第二代理就不需要了）
    3、逐段传输头有：Keep-Alive,Transfer-Encoding,TE,Connection,Trailer,Upgrade,Proxy-Authorization,Proxy-Authenticate
    

6、ReverseProxy的特殊StatusCode

    100：表示一切正常，客户端可以继续请求 continue
    101：服务端发送给客户端升级协议的请求

    
    100 ：
        1、客户端要Post的数据大于1024字节的时候
        2、客户端不会直接就发起post请求，而是会分为两步：
            a、发送一个请求，包含一个Expect：100-continue，询问Server是否愿意接收数据
            b、接收到Server返回的100-continue应答后，返回100状态，才会把数据post给Server
    101：切换协议的状态码

7、ReverseProxy的特殊Header头：ReverseProxy内部有一些关闭header头的逻辑，有助于理解http代理的实现细节

    1、X-Forwarded-For：记录每一个反向代理的ip，可能会被伪造：client_ip,proxy_ip1,proxy_ip2
    2、X-Real-IP：实际请求的ip即client_ip:每经过一层代理都会被覆盖掉，只需要在第一代理设置转发。不会被伪造
    3、Connection：这个链接是关闭还是长连接，或者升级链接
    4、TE 表示希望使用的传输编码类型
    5、Trailer允许发送方在消息后边添加额外的元信息
    
    第一代理去除标准的逐段传输头（hop-by-hop）

8、ReverseProxy源码分析

    func (p *ReverseProxy)ServeHttp: 即实现了handler接口，所以可以传到http.ListenAndServe(addr,ReverseProxy)中
    1、验证是否请求终止（例如客户突然关闭浏览器，则终止）
    2、设置请求ctx信息
    3、深拷贝header
    4、修改req
    5、Upgrde头的特殊处理
    6、追加clientIp信息
    7、向下游请求数据   
    8、处理升级协议请求
    9、移除逐段头部
    10、修改返回内容
    11、拷贝头部数据
    12、写入状态码
    13、周期性的刷新内容到response


        func (p *ReverseProxy) ServeHTTP(rw http.ResponseWriter, req *http.Request) {
            transport := p.Transport
            // 验证是否设置了连接池，如果没有就使用默认的连接池
            if transport == nil {
                transport = http.DefaultTransport
            }
            
            // 验证请求是否终止，例如关闭了浏览器
            ctx := req.Context()
            if cn, ok := rw.(http.CloseNotifier); ok {
                var cancel context.CancelFunc
                ctx, cancel = context.WithCancel(ctx)
                defer cancel()
                // 取出通知的channel
                notifyChan := cn.CloseNotify()
                go func() {
                    select {
                    case <-notifyChan:
                        // 如果接受了取消的通知，就取消这个请求
                        cancel()
                    case <-ctx.Done():
                    }
                }()
            }
        
            // 设置ctx信息：深拷贝header,将上游的header复制到下游的header中
            outreq := req.Clone(ctx)
            if req.ContentLength == 0 {
                outreq.Body = nil // Issue 16036: nil Body for http.Transport retries
            }
            if outreq.Body != nil {
                // Reading from the request body after returning from a handler is not
                // allowed, and the RoundTrip goroutine that reads the Body can outlive
                // this handler. This can lead to a crash if the handler panics (see
                // Issue 46866). Although calling Close doesn't guarantee there isn't
                // any Read in flight after the handle returns, in practice it's safe to
                // read after closing it.
                不允许在从处理程序返回后读取请求正文，并且读取正文的 RoundTrip goroutine 可以比此处理程序更长寿。 
                如果处理程序出现恐慌，这可能会导致崩溃（请参阅问题 46866）。 
                尽管调用 Close 并不能保证在句柄返回后没有任何 Read 在运行中，但实际上在关闭它之后读取是安全的。
                defer outreq.Body.Close()
            }
            if outreq.Header == nil {
                outreq.Header = make(http.Header) // Issue 33142: historical behavior was to always allocate
            }
        
            // 修改req 此函数可以对请求的信息进行修改 
            p.Director(outreq)
            outreq.Close = false //这条请求连接是可以被复用的
        
            // upgrade头的特殊处理
            reqUpType := upgradeType(outreq.Header)
            if !ascii.IsPrint(reqUpType) {
                p.getErrorHandler()(rw, req, fmt.Errorf("client tried to switch to invalid protocol %q", reqUpType))
                return
            }
            // 删除Connection的Headers信息
            removeConnectionHeaders(outreq.Header)
        
            // Remove hop-by-hop headers to the backend. Especially
            // important is "Connection" because we want a persistent
            // connection, regardless of what the client sent to us.
            // 删除后端的逐段header头，尤其重要的是连接，因为我们需要一个持久的连接，而不是客户端发送给我们什么
            // 逐段header头不应该发送到第二代理及之后
            for _, h := range hopHeaders {
                outreq.Header.Del(h)
            }
        
            // Issue 21096: tell backend applications that care about trailer support
            // that we support trailers. (We do, but we don't go out of our way to
            // advertise that unless the incoming client request thought it was worth
            // mentioning.) Note that we look at req.Header, not outreq.Header, since
            // the latter has passed through removeConnectionHeaders.
            if httpguts.HeaderValuesContainsToken(req.Header["Te"], "trailers") {
                outreq.Header.Set("Te", "trailers")
            }
        
            // After stripping all the hop-by-hop connection headers above, add back any
            // necessary for protocol upgrades, such as for websockets.
            // 如果upgrade不为空就设置
            if reqUpType != "" {
                outreq.Header.Set("Connection", "Upgrade")
                outreq.Header.Set("Upgrade", reqUpType)
            }
            
            // 追加client ip的信息
            if clientIP, _, err := net.SplitHostPort(req.RemoteAddr); err == nil {
                // If we aren't the first proxy retain prior
                // X-Forwarded-For information as a comma+space
                // separated list and fold multiple headers into one.
                prior, ok := outreq.Header["X-Forwarded-For"]
                omit := ok && prior == nil // Issue 38079: nil now means don't populate the header
                if len(prior) > 0 {
                    clientIP = strings.Join(prior, ", ") + ", " + clientIP
                }
                if !omit {
                    // 主要是追加X-Forwarded-For信息
                    outreq.Header.Set("X-Forwarded-For", clientIP)
                }
            }
        
            // 向下游请求的数据
            res, err := transport.RoundTrip(outreq)
            if err != nil {
                p.getErrorHandler()(rw, outreq, err)
                return
            }
            
            // 升级协议请求
            // Deal with 101 Switching Protocols responses: (WebSocket, h2c, etc)
            if res.StatusCode == http.StatusSwitchingProtocols {
                    // 修改返回信息
                if !p.modifyResponse(rw, res, outreq) {
                    return
                }
                // 升级协议请求：比较上下游协议是否都升级成功了-》拷贝header头信息（把下游的请求header拷贝到上游）
                p.handleUpgradeResponse(rw, outreq, res)
                // 升级成功直接返回
                return
            }
        
            // 没有升级成功，需要移除逐段头部数据：要将下游返回的无用的逐段头部数据删除
            removeConnectionHeaders(res.Header)
        
            for _, h := range hopHeaders {
                res.Header.Del(h)
            }
        
            // 更改返回内容
            if !p.modifyResponse(rw, res, outreq) {
                return
            }
            
            // 拷贝头部数据 将下游的res.Header，拷贝到上游rw.Header()
            copyHeader(rw.Header(), res.Header)
        
            // The "Trailer" header isn't included in the Transport's response,
            // at least for *http.Transport. Build it up from Trailer.
            // 处理Trailer
            announcedTrailers := len(res.Trailer)
            if announcedTrailers > 0 {
                trailerKeys := make([]string, 0, len(res.Trailer))
                for k := range res.Trailer {
                    trailerKeys = append(trailerKeys, k)
                }
                rw.Header().Add("Trailer", strings.Join(trailerKeys, ", "))
            }
            
            // 写入状态码：返回给客户端的状态
            rw.WriteHeader(res.StatusCode)
        
            // 周期刷新内容到response
            err = p.copyResponse(rw, res.Body, p.flushInterval(res))
            if err != nil {
                defer res.Body.Close()
                // Since we're streaming the response, if we run into an error all we can do
                // is abort the request. Issue 23643: ReverseProxy should use ErrAbortHandler
                // on read error while copying body.
                if !shouldPanicOnCopyError(req) {
                    p.logf("suppressing panic for copyResponse error in test; copy error: %v", err)
                    return
                }
                panic(http.ErrAbortHandler)
            }
            // 读取完成后，现在可以关闭了
            res.Body.Close() // close now, instead of defer, to populate res.Trailer
        
            // trailer逻辑处理
            if len(res.Trailer) > 0 {
                // Force chunking if we saw a response trailer.
                // This prevents net/http from calculating the length for short
                // bodies and adding a Content-Length.
                if fl, ok := rw.(http.Flusher); ok {
                    fl.Flush()
                }
            }
        
            if len(res.Trailer) == announcedTrailers {
                copyHeader(rw.Header(), res.Trailer)
                return
            }
        
            for k, vv := range res.Trailer {
                k = http.TrailerPrefix + k
                for _, v := range vv {
                    rw.Header().Add(k, v)
                }
            }
        }

    
    
[在反向代理中加入负载均衡] proxy/load_balance/factory.go

---

[HTTP代理进阶] demo/proxy/middleware/main.go

1、 中间件

这是中间件充当业务逻辑的实现：初始化路由；为不同的路由使用不同的中间件+业务逻辑代码 （）
中间件做反向代理：/ .use 中间件+反向代理的ServerHTTP方法：

    package main

    import (
    "fmt"
    "github.com/e421083458/gateway_demo/proxy/middleware"
    "github.com/e421083458/gateway_demo/proxy/proxy"
    "log"
    "net/http"
    "net/url"
    )
    
    var addr = "127.0.0.1:2002"
    
    func main() {
    reverseProxy := func(c *middleware.SliceRouterContext) http.Handler {
            rs1 := "http://127.0.0.1:2003/base"
            url1, err1 := url.Parse(rs1)
            if err1 != nil {
                log.Println(err1)
            }
    
            rs2 := "http://127.0.0.1:2004/base"
            url2, err2 := url.Parse(rs2)
            if err2 != nil {
                log.Println(err2)
            }
    
            urls := []*url.URL{url1, url2}
            return proxy.NewMultipleHostsReverseProxy(c, urls)
        }
        log.Println("Starting httpserver at " + addr)
    
        //初始化方法数组路由器
        sliceRouter := middleware.NewSliceRouter()
    
        //中间件可充当业务逻辑代码
        sliceRouter.Group("/base").Use(middleware.TraceLogSliceMW(), func(c *middleware.SliceRouterContext) {
            c.Rw.Write([]byte("test func"))
        })
    
        //请求到反向代理
        sliceRouter.Group("/").Use(middleware.TraceLogSliceMW(), func(c *middleware.SliceRouterContext) {
            fmt.Println("reverseProxy")
            reverseProxy(c).ServeHTTP(c.Rw, c.Req)
        })
        // 把路由器组装成一个handler的实现 :将coreFunc设置为了nil
        routerHandler := middleware.NewSliceRouterHandler(nil, sliceRouter)
        log.Fatal(http.ListenAndServe(addr, routerHandler))
    }

使用方法数组构建中间件 实现思路：

路由器：/    ->  方法数组：方法1-》方法2-》反向代理
      /base -> 方法数组：方法1-》方法2-》业务方法

https://github.com/e421083458/gateway_demo/blob/master/proxy/middleware/slice_router.go

    type HandlerFunc func(*SliceRouterContext)

    // router 结构体
    type SliceRouter struct {
        groups []*SliceGroup
    }
    
    // group 结构体
    type SliceGroup struct {
        *SliceRouter // 路由器的结构体
        path     string // 当前注册的前缀
        handlers []HandlerFunc // 回调的方法数组
    }
    
    // router上下文
    type SliceRouterContext struct {
        Rw  http.ResponseWriter
        Req *http.Request
        Ctx context.Context
        *SliceGroup
        index int8
    }


        // 创建 Group
        func (g *SliceRouter) Group(path string) *SliceGroup {
            return &SliceGroup{
                SliceRouter: g,
                path:        path,
            }
        }


    // 构造回调方法
    func (g *SliceGroup) Use(middlewares ...HandlerFunc) *SliceGroup {
        // 将中间件加入到对应的sliceGroup中
        g.handlers = append(g.handlers, middlewares...)
        existsFlag := false
        for _, oldGroup := range g.SliceRouter.groups {
            if oldGroup == g {
                existsFlag = true
            }
        }
        // 如果不存在,就把它加入到groups数组中
        if !existsFlag {
            g.SliceRouter.groups = append(g.SliceRouter.groups, g)
        }
    
        return g
    }

    中间件的调用：怎么把中间件暴露给server，让server可以调用中间件。也就是要把中间件封装成http handler接口
    1、设置路由器
    2、实现handler接口中的ServeHTTP方法：遍历路由器中的路由，找到对应的路由，然后找到路由中的方法数组，通过移动索引index，来实现方法的调用


    type SliceRouterHandler struct {
        coreFunc func(*SliceRouterContext) http.Handler  
        router   *SliceRouter
    }
    func NewSliceRouterHandler(coreFunc func(*SliceRouterContext) http.Handler, router *SliceRouter) *SliceRouterHandler {
        return &SliceRouterHandler{
            coreFunc: coreFunc,
            router:   router,
        }
    }
    SliceRouterHandler 是实现了handler接口
    func (w *SliceRouterHandler) ServeHTTP(rw http.ResponseWriter, req *http.Request) {
        c := newSliceRouterContext(rw, req, w.router)
        if w.coreFunc != nil {
            c.handlers = append(c.handlers, func(c *SliceRouterContext) {
                w.coreFunc(c).ServeHTTP(rw, req)
            })
        }
        c.Reset()
        c.Next()
    }
    
    // router上下文
    type SliceRouterContext struct {
        Rw  http.ResponseWriter
        Req *http.Request
        Ctx context.Context
        *SliceGroup
        index int8  使用索引来直接操作回调函数
    }

         // 在context中控制了索引index的增加和终止
        // 从最先加入中间件开始回调
        func (c *SliceRouterContext) Next() {
            c.index++
            for c.index < int8(len(c.handlers)) {
                //fmt.Println("c.index")
                //fmt.Println(c.index)
                c.handlers[c.index](c)
                c.index++
            }
        }
        
        // 跳出中间件方法
        func (c *SliceRouterContext) Abort() {
            c.index = abortIndex
        }
        
        // 是否跳过了回调
        func (c *SliceRouterContext) IsAborted() bool {
            return c.index >= abortIndex
        }
        
        // 重置回调
        func (c *SliceRouterContext) Reset() {
            c.index = -1
        }

    func newSliceRouterContext(rw http.ResponseWriter, req *http.Request, r *SliceRouter) *SliceRouterContext {
        newSliceGroup := &SliceGroup{}
    
        //最长url前缀匹配
        matchUrlLen := 0
        for _, group := range r.groups {
            //fmt.Println("req.RequestURI")
            //fmt.Println(req.RequestURI)
            if strings.HasPrefix(req.RequestURI, group.path) {
                pathLen := len(group.path)
                if pathLen > matchUrlLen {
                    matchUrlLen = pathLen
                    *newSliceGroup = *group //浅拷贝数组指针 :数组的内容是一个指针，但是lenght已经是拷贝出去了，length都是固定大小
                }
            }
        }
    
        c := &SliceRouterContext{Rw: rw, Req: req, SliceGroup: newSliceGroup, Ctx: req.Context()}
        c.Reset()
        return c
    }

[并发限速的意义]：
    
    限流：限流原理；网关集成限流
    1、限流的意义：通过并发限速，以达到拒绝服务、排队、等待、降级的目的
    2、限流分类：漏桶限流（每次请求时计算桶的流量，超过阀值则降低请求）；令牌桶限流（每次请求时从桶中获取令牌，取不到则降级请求，以固定速率向桶中添加令牌，桶满了丢弃多于的令牌）
    3、time/rate 限速器的使用
        limiter：=rate.NewLimiter(limit,burst) limit表示每秒产生token数，burst为最多可以存储的token数
        limiter有有三个公共方法：
            Allow判断当前是否可以取到token，返回bool
            Wait阻塞等待之道取到token
            Reserve返回等待预估时间，时间到了再去取token
        
        import (
        "context"
        "golang.org/x/time/rate"
        "log"
        "testing"
        "time"
        )

        func Test_RateLimiter(t *testing.T) {
            l := rate.NewLimiter(1, 5)
            log.Println(l.Limit(), l.Burst())

            for i := 0; i < 100; i++ {
                //阻塞等待直到，取到一个token
                log.Println("before Wait")
                c, _ := context.WithTimeout(context.Background(), time.Second*2)
        
                if err := l.Wait(c); err != nil {
                     log.Println("limiter wait err:" + err.Error())
                }
                log.Println("after Wait")
                
                 //返回需要等待多久才有新的token,这样就可以等待指定时间执行任务
                 r := l.Reserve()
                 log.Println("reserve Delay:", r.Delay())
                
                 //判断当前是否可以取到token
                 a := l.Allow()
                 log.Println("Allow:", a)
            }
        }
    4、time/rate 源码分析
        实现思路：会计算上次请求和当前请求的时间差，根据时间差生成token数+旧token数，这两个数之和不能大于桶容量
                如果token为负数，也就是桶是空的，就计算等待的时间；如果token是正数，也就是桶中有token，则token-1

        type Limiter struct{
            limit Limit // 每秒生成token数
            burst int // 桶数
            mu sync.Mutex 
            tokens float64 // 令牌数
            last time.time // 最后一次令牌更新的时间
            lastEvent time.Time  // 最后一次限速的时间
        }

        创建限流器，在每次请求的时候先确认能不能拿到令牌，如果不能就打印日志：关于限流的信息，每秒钟产生的数量，桶的容量，然后终止中间件abort。
        如果拿到了就执行下一个中间件next():
        func RateLimiter ()func(c *SliceRouterContext){
            l:=rate.NewLimiter{1,2}
            return func (c *DliceRouterContext){
                if !l.Allow(){
                    c.Rw.Write([]byte(fmt.Sprintf("rate limit:%v,%v",l.Limit,l.Burst)))
                    c.Abort()
                    return
                }
                c.Next()
            }
        }
            

    熔断与降级：熔断降级原理；网关集成熔断与降级
    熔断的意义： 当依赖的服务已经出现故障，为了保证自身服务的正常运行不再访问依赖的服务，防止雪崩效应
    降级的意义：当服务器压力剧增时，根据业务策略降级，以此释放服务资源保证业务正常。

    在熔断发生后，才会进行降级，一般是搭配来使用的

            import (
            "github.com/e421083458/gateway_demo/proxy/middleware"
            "github.com/e421083458/gateway_demo/proxy/proxy"
            "github.com/e421083458/gateway_demo/proxy/public"
            "log"
            "net/http"
            "net/url"
            )
            
            var addr = "127.0.0.1:2002"
            
            // 熔断方案
            func main() {
                coreFunc := func(c *middleware.SliceRouterContext) http.Handler {
                rs1 := "http://127.0.0.1:2003/base"
                url1, err1 := url.Parse(rs1)
                if err1 != nil {
                    log.Println(err1)
                }
            
                    rs2 := "http://127.0.0.1:2004/base"
                    url2, err2 := url.Parse(rs2)
                    if err2 != nil {
                        log.Println(err2)
                    }
            
                    urls := []*url.URL{url1, url2}
                    return proxy.NewMultipleHostsReverseProxy(c, urls)
                }
                log.Println("Starting httpserver at " + addr)
            
                public.ConfCricuitBreaker(true)
                sliceRouter := middleware.NewSliceRouter()
                sliceRouter.Group("/").Use(middleware.CircuitMW())
                routerHandler := middleware.NewSliceRouterHandler(coreFunc, sliceRouter)
                log.Fatal(http.ListenAndServe(addr, routerHandler))
            }

---
[websocket协议]

Connection Header头意义：
    1、标记请求方与第一代理的状态（可以是第一代理，也可以是后端服务器）
    2、决定了当前事务完成后，是否关闭网络： keep-alive 不关闭网络  close：关闭网络 Upgrade：协议升级

websocket代理实战：测试服务器+ websocket代理

测试服务器：https://git.imooc.com/coding-436/gateway_demo/src/master/demo/proxy/websocket/server/main.go

websocket代理：

深入理解upgrader.Upgrade 是websocket类库：
    1、获取websocket 的key
    2、通过sha1生成 websocket-Accept key
    3、向客户端发送101状态码
    4、服务端会接收到一个websocket.connection,其中封装了两个方法writemessage 和readmessage

[https、http2、http1.1之间的区别]https、http2的代理实现

    https与HTTP的区别：
    1、https是http协议的加密版，http的传输是明文的，https使用ttl/tls进行了加密
    2、https与http使用的连接方式是不同的，默认的端口也不一样
    
    http1.1与HTTP2的区别
    1、http2采用二进制格式，http2使用一个链接实现多路复用
    2、http2使用报头压缩，降低了开销
    3、http2可以让服务端的响应主动"推送"到客户端
    4、http2增加了一些以 ： 开头的header 如:authority :method
    5、protocol：http/1.1 scheme:http(s) ;  protocol:h2 scheme:https http2的只能是https

    http2与https的关系：
    1、http2代表多路复用的传输协议
    2、https代表http服务器使用了加密传输
    3、一个启用了https的服务器，不一定使用了http2
    4、但是使用了http2的服务器必须启用了https
    
    http2的设计目标：
    1、解决了http1.1中的"队头阻塞"的问题
    2、并行操作无需与服务器建立多个连接，复用一个链接就可以
    3、保持了http1.1中的语义，通过添加新的header扩展了http1.1

    http2基本概念：
    1、流：是连接中的一个虚拟信道，可以承载双向的消息
    2、消息：指逻辑上的http消息，比如请求、响应等
    3、帧：http2 通信的最小单位，每个帧包含帧的首部，至少也会表示出当前帧所属的流，承载着特定类型的数据
    
    http2的多路复用：
    客户端与服务端建立了一个tcp连接，这个tcp连接中可能有多个流：stream1；stream3；

    http2的首部压缩：
    不需要发送重复的header，只需要发送不同的header项即可
    
    http2的协议磋商：
    询问服务端是否支持http2，不支持则降为http1.1
    1、客户端发起一个http1.1的请求，其中带有有http2 Upgrade首部，代表询问是否支持升级http2
    2、服务端拒接升级的话，就会返回http1.1的响应
    3、服务端接受升级到http2，就切换到新的分帧，使用http2的协议返回消息

    http2的请求流程：
    1、tcp三次握手
    2、tls握手
    3、htt2传输
    4、tcp四次挥手
    
    
    
[https与http2代理实现]
1、创建下游的测试服务器：https://git.imooc.com/coding-436/gateway_demo/src/master/demo/proxy/reverse_proxy_https/real_server/main.go


        func (r *RealServer) Run() {
            log.Println("Starting httpserver at " + r.Addr)
            mux := http.NewServeMux()
            mux.HandleFunc("/", r.HelloHandler)
            mux.HandleFunc("/base/error", r.ErrorHandler)

            server := &http.Server{
                Addr:         r.Addr,
                WriteTimeout: time.Second * 3,
                Handler:      mux,
            }
            go func() {
                // https协议数据如何转换为http明文请求？ 
                // 传入创建的server，即使用http2协议：1、设置了http2对应的handler回调 2、在http.Server中设置了对http2的回调
                // http2的回调负责从帧数据流中 将数据转换为http请求体
                http2.ConfigureServer(server, &http2.Server{})
                // ListenAndServeTLS 支持https ，并传入服务器的证书和私钥
                log.Fatal(server.ListenAndServeTLS(testdata.Path("server.crt"), testdata.Path("server.key")))
            }()
        }


        func ConfigureServer(s *http.Server, conf *Server) error {
            if s == nil {
                panic("nil *http.Server")
            }
            if conf == nil {
                conf = new(Server)
            }
        conf.state = &serverInternalState{activeConns: make(map[*serverConn]struct{})}
        
            if h1, h2 := s, conf; h2.IdleTimeout == 0 {
                if h1.IdleTimeout != 0 {
                    h2.IdleTimeout = h1.IdleTimeout
                } else {
                    h2.IdleTimeout = h1.ReadTimeout
                }
            }
        s.RegisterOnShutdown(conf.state.startGracefulShutdown)
        
            if s.TLSConfig == nil {
                s.TLSConfig = new(tls.Config)
            } else if s.TLSConfig.CipherSuites != nil && s.TLSConfig.MinVersion < tls.VersionTLS13 {
                // If they already provided a TLS 1.0–1.2 CipherSuite list, return an
                // error if it is missing ECDHE_RSA_WITH_AES_128_GCM_SHA256 or
                // ECDHE_ECDSA_WITH_AES_128_GCM_SHA256.
                haveRequired := false
                for _, cs := range s.TLSConfig.CipherSuites {
                    switch cs {
                    case tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
                        // Alternative MTI cipher to not discourage ECDSA-only servers.
                        // See http://golang.org/cl/30721 for further information.
                        tls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:
                        haveRequired = true
                    }
                }
                if !haveRequired {
                    return fmt.Errorf("http2: TLSConfig.CipherSuites is missing an HTTP/2-required AES_128_GCM_SHA256 cipher (need at least one of TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 or TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256)")
                }
            }
        
            // Note: not setting MinVersion to tls.VersionTLS12,
            // as we don't want to interfere with HTTP/1.1 traffic
            // on the user's server. We enforce TLS 1.2 later once
            // we accept a connection. Ideally this should be done
            // during next-proto selection, but using TLS <1.2 with
            // HTTP/2 is still the client's bug.
        
            s.TLSConfig.PreferServerCipherSuites = true
        
            if !strSliceContains(s.TLSConfig.NextProtos, NextProtoTLS) {
                s.TLSConfig.NextProtos = append(s.TLSConfig.NextProtos, NextProtoTLS)
            }
            if !strSliceContains(s.TLSConfig.NextProtos, "http/1.1") {
                s.TLSConfig.NextProtos = append(s.TLSConfig.NextProtos, "http/1.1")
            }
        
            if s.TLSNextProto == nil {
                s.TLSNextProto = map[string]func(*http.Server, *tls.Conn, http.Handler){}
            }
            
            // 
            protoHandler := func(hs *http.Server, c *tls.Conn, h http.Handler) {
                if testHookOnConn != nil {
                    testHookOnConn()
                }
                // The TLSNextProto interface predates contexts, so
                // the net/http package passes down its per-connection
                // base context via an exported but unadvertised
                // method on the Handler. This is for internal
                // net/http<=>http2 use only.
                var ctx context.Context
                type baseContexter interface {
                    BaseContext() context.Context
                }
                if bc, ok := h.(baseContexter); ok {
                    ctx = bc.BaseContext()
                }
                conf.ServeConn(c, &ServeConnOpts{
                    Context:    ctx,
                    Handler:    h,
                    BaseConfig: hs,
                })
            }
            // 将protoHandler 指向当前的http2协议
            // 谁来调用这个协议呢？
            s.TLSNextProto[NextProtoTLS] = protoHandler
            return nil
        }      


        func (srv *Server) ServeTLS(l net.Listener, certFile, keyFile string) error {
        // Setup HTTP/2 before srv.Serve, to initialize srv.TLSConfig
        // before we clone it and create the TLS Listener.

        if err := srv.setupHTTP2_ServeTLS(); err != nil {
            return err
        }
        
            config := cloneTLSConfig(srv.TLSConfig)
            // 协议磋商，如果服务器不支持http2，就会返回http1.1的响应
            if !strSliceContains(config.NextProtos, "http/1.1") {
                config.NextProtos = append(config.NextProtos, "http/1.1")
            }
        
            configHasCert := len(config.Certificates) > 0 || config.GetCertificate != nil
            if !configHasCert || certFile != "" || keyFile != "" {
                var err error
                config.Certificates = make([]tls.Certificate, 1)
                config.Certificates[0], err = tls.LoadX509KeyPair(certFile, keyFile)
                if err != nil {
                    return err
                }
            }
        
            tlsListener := tls.NewListener(l, config)
            return srv.Serve(tlsListener)
        }

     func (srv *Server) Serve(l net.Listener) error {
        if fn := testHookServerServe; fn != nil {
            fn(srv, l) // call hook with unwrapped listener
        }
    
        origListener := l
        l = &onceCloseListener{Listener: l}
        defer l.Close()
    
        if err := srv.setupHTTP2_Serve(); err != nil {
            return err
        }
    
        if !srv.trackListener(&l, true) {
            return ErrServerClosed
        }
        defer srv.trackListener(&l, false)
    
        baseCtx := context.Background()
        if srv.BaseContext != nil {
            baseCtx = srv.BaseContext(origListener)
            if baseCtx == nil {
                panic("BaseContext returned a nil context")
            }
        }
    
        var tempDelay time.Duration // how long to sleep on accept failure
    
        ctx := context.WithValue(baseCtx, ServerContextKey, srv)
        // 获取请求
        for {
            rw, err := l.Accept()
            if err != nil {
                select {
                case <-srv.getDoneChan():
                    return ErrServerClosed
                default:
                }
                if ne, ok := err.(net.Error); ok && ne.Temporary() {
                    if tempDelay == 0 {
                        tempDelay = 5 * time.Millisecond
                    } else {
                        tempDelay *= 2
                    }
                    if max := 1 * time.Second; tempDelay > max {
                        tempDelay = max
                    }
                    srv.logf("http: Accept error: %v; retrying in %v", err, tempDelay)
                    time.Sleep(tempDelay)
                    continue
                }
                return err
            }
            connCtx := ctx
            if cc := srv.ConnContext; cc != nil {
                connCtx = cc(connCtx, rw)
                if connCtx == nil {
                    panic("ConnContext returned nil")
                }
            }
            tempDelay = 0
            c := srv.newConn(rw)
            c.setState(c.rwc, StateNew, runHooks) // before Serve can return
            go c.serve(connCtx)
        }
    }

    // Serve a new connection.
    func (c *conn) serve(ctx context.Context) {

    c.remoteAddr = c.rwc.RemoteAddr().String()
    ctx = context.WithValue(ctx, LocalAddrContextKey, c.rwc.LocalAddr())

    defer func() {
        if err := recover(); err != nil && err != ErrAbortHandler {
            const size = 64 << 10
            buf := make([]byte, size)
            buf = buf[:runtime.Stack(buf, false)]
            c.server.logf("http: panic serving %v: %v\n%s", c.remoteAddr, err, buf)
        }
        if !c.hijacked() {
            c.close()
            c.setState(c.rwc, StateClosed, runHooks)
        }
    }()
        // 向下转型了tls.Conn，能转型成功说明是加密的连接
        if tlsConn, ok := c.rwc.(*tls.Conn); ok {
            if d := c.server.ReadTimeout; d > 0 {
                c.rwc.SetReadDeadline(time.Now().Add(d))
            }
            if d := c.server.WriteTimeout; d > 0 {
                c.rwc.SetWriteDeadline(time.Now().Add(d))
            }
            // 验证 是否是tls的连接
            if err := tlsConn.HandshakeContext(ctx); err != nil {
                // If the handshake failed due to the client not speaking
                // TLS, assume they're speaking plaintext HTTP and write a
                // 400 response on the TLS conn's underlying net.Conn.
                if re, ok := err.(tls.RecordHeaderError); ok && re.Conn != nil && tlsRecordHeaderLooksLikeHTTP(re.RecordHeader) {
                    io.WriteString(re.Conn, "HTTP/1.0 400 Bad Request\r\n\r\nClient sent an HTTP request to an HTTPS server.\n")
                    re.Conn.Close()
                    return
                }
                c.server.logf("http: TLS handshake error from %s: %v", c.rwc.RemoteAddr(), err)
                return
            }
            c.tlsState = new(tls.ConnectionState)
            *c.tlsState = tlsConn.ConnectionState()
            if proto := c.tlsState.NegotiatedProtocol; validNextProto(proto) {
                // 这个fn就是设置的回调方法
                if fn := c.server.TLSNextProto[proto]; fn != nil {
                    h := initALPNRequest{ctx, tlsConn, serverHandler{c.server}}
                    // Mark freshly created HTTP/2 as active and prevent any server state hooks
                    // from being run on these connections. This prevents closeIdleConns from
                    // closing such connections. See issue https://golang.org/issue/39776.
                    c.setState(c.rwc, StateActive, skipHooks)
                    // 传入了 server connection 和handler
                    fn(c.server, tlsConn, h)
                }
                return
            }
        }
    
        // HTTP/1.x from here on.
    
        ctx, cancelCtx := context.WithCancel(ctx)
        c.cancelCtx = cancelCtx
        defer cancelCtx()
    
        c.r = &connReader{conn: c}
        c.bufr = newBufioReader(c.r)
        c.bufw = newBufioWriterSize(checkConnErrorWriter{c}, 4<<10)
    
        for {
            w, err := c.readRequest(ctx)
            if c.r.remain != c.server.initialReadLimitSize() {
                // If we read any bytes off the wire, we're active.
                c.setState(c.rwc, StateActive, runHooks)
            }
            if err != nil {
                const errorHeaders = "\r\nContent-Type: text/plain; charset=utf-8\r\nConnection: close\r\n\r\n"
    
                switch {
                case err == errTooLarge:
                    // Their HTTP client may or may not be
                    // able to read this if we're
                    // responding to them and hanging up
                    // while they're still writing their
                    // request. Undefined behavior.
                    const publicErr = "431 Request Header Fields Too Large"
                    fmt.Fprintf(c.rwc, "HTTP/1.1 "+publicErr+errorHeaders+publicErr)
                    c.closeWriteAndWait()
                    return
    
                case isUnsupportedTEError(err):
                    // Respond as per RFC 7230 Section 3.3.1 which says,
                    //      A server that receives a request message with a
                    //      transfer coding it does not understand SHOULD
                    //      respond with 501 (Unimplemented).
                    code := StatusNotImplemented
    
                    // We purposefully aren't echoing back the transfer-encoding's value,
                    // so as to mitigate the risk of cross side scripting by an attacker.
                    fmt.Fprintf(c.rwc, "HTTP/1.1 %d %s%sUnsupported transfer encoding", code, StatusText(code), errorHeaders)
                    return
    
                case isCommonNetReadError(err):
                    return // don't reply
    
                default:
                    if v, ok := err.(statusError); ok {
                        fmt.Fprintf(c.rwc, "HTTP/1.1 %d %s: %s%s%d %s: %s", v.code, StatusText(v.code), v.text, errorHeaders, v.code, StatusText(v.code), v.text)
                        return
                    }
                    publicErr := "400 Bad Request"
                    fmt.Fprintf(c.rwc, "HTTP/1.1 "+publicErr+errorHeaders+publicErr)
                    return
                }
            }
    
            // Expect 100 Continue support
            req := w.req
            if req.expectsContinue() {
                if req.ProtoAtLeast(1, 1) && req.ContentLength != 0 {
                    // Wrap the Body reader with one that replies on the connection
                    req.Body = &expectContinueReader{readCloser: req.Body, resp: w}
                    w.canWriteContinue.setTrue()
                }
            } else if req.Header.get("Expect") != "" {
                w.sendExpectationFailed()
                return
            }
    
            c.curReq.Store(w)
    
            if requestBodyRemains(req.Body) {
                registerOnHitEOF(req.Body, w.conn.r.startBackgroundRead)
            } else {
                w.conn.r.startBackgroundRead()
            }
    
            // HTTP cannot have multiple simultaneous active requests.[*]
            // Until the server replies to this request, it can't read another,
            // so we might as well run the handler in this goroutine.
            // [*] Not strictly true: HTTP pipelining. We could let them all process
            // in parallel even if their responses need to be serialized.
            // But we're not going to implement HTTP pipelining because it
            // was never deployed in the wild and the answer is HTTP/2.
            serverHandler{c.server}.ServeHTTP(w, w.req)
            w.cancelCtx()
            if c.hijacked() {
                return
            }
            w.finishRequest()
            if !w.shouldReuseConnection() {
                if w.requestBodyLimitHit || w.closedRequestBodyEarly() {
                    c.closeWriteAndWait()
                }
                return
            }
            c.setState(c.rwc, StateIdle, runHooks)
            c.curReq.Store((*response)(nil))
    
            if !w.conn.server.doKeepAlives() {
                // We're in shutdown mode. We might've replied
                // to the user without "Connection: close" and
                // they might think they can send another
                // request, but such is life with HTTP/1.1.
                return
            }
    
            if d := c.server.idleTimeout(); d != 0 {
                c.rwc.SetReadDeadline(time.Now().Add(d))
                if _, err := c.bufr.Peek(4); err != nil {
                    return
                }
            }
            c.rwc.SetReadDeadline(time.Time{})
        }
    }


2、https的代理整合网关

---

[四层tcp代理 ] tcp代理的原理；tcp代理实现；tcp代理测试thrift、redis、http、websocket、https；tcp扩展中间件的支持（用以做权限校验、限流等操作）

    osi模型与tcp协议数据包：osi参考模型；tcp/ip参考模型；tcp/ip协议栈

    四层负载均衡原理

    七层负载均衡原理

    四层负载和七层负载的区别


    
    
    