什么是网络代理？
1、用户通过代理请求信息
2、请求通过网络dialing完成转发到目标服务器
3、目标服务器响应后再通过代理传回给用户

网络代理 和 网络转发的区别是什么？

网络代理：用户直接连接代理服务器，由代理服务器连接后端服务。
网络转发：是路由器对报文的转发操作，中间也可能对数据包进行修改

网络代理的类型？
1、正向代理
    是一个客户端的代理技术，帮助客户端访问无法访问的服务资源，可以隐藏用户的真实ip，比如浏览器web代理、vpn
2、反向代理
    是一个服务端的代理技术，帮助服务器做负载均衡、缓存、提供安全校验等，可以隐藏服务器真实ip
    比如LVS\nginx proxy_pass等


实现一个web浏览器代理：
    正向代理：
    1、代理接收客户端请求、复制原请求对象、并根据数据配置请求各种参数
    2、把请求发送的目标服务器，并接收服务器的返回数据
    3、代理服务器做一些处理，然后返回给客户端

用户发来请求-》代理服务器监听中-》上游tcp连接-》回调方法-》拷贝数据-》请求下游服务transport RoundTrip-》回写上游数据

实现一个反向代理：

[简版的http反向代理]
    这功能比较复杂，先实现一个简版的http反向代理
    1、代理接收客户端请求，更改请求结构体
    2、通过一定的负载均衡算法获取下游服务地址
    3、把请求发送到下游服务器，并获取返回内容
    4、对返回内容做一些处理，饭后返会给客户端

[完整版http代理]
简版的http代理，不具备哪些功能？
    1、错误回调及错误日志处理
    2、更改dialing返回内容
    3、负载均衡
    4、url重写
    5、限流、熔断、降级
    6、数据统计
    7、权限验证
    
 http代理大纲：用ReverseProxy实现一个http代理
    1、ReverseProxy的功能点
    2、ReverseProxy演示
    3、ReverseProxy源码分析
    4、扩展ReverseProxy功能：
        a、四种负载均衡类型的实现及接口封装；
        b、扩展中间件的支持（限流、熔断、权限、数据统计）

ReverseProxy的功能点：
    1、可以更改内容
    2、错误信息回调
    3、支持自定义负载均衡
    4、url重写功能
    5、连接池功能
    6、支持websocket服务（独立章节介绍）
    7、支持https代理（独立章节介绍）

1、ReverseProxy实现了ServeHTTP()，即实现了Handler接口 :


2、ReverseProxy更改内容的支持：demo/proxy/reverse_proxy_step

type ReverseProxy struct{
    // 控制器必须是一个函数，此函数可以对请求的信息进行修改
    Director func(*http.Request)、
    // 连接池，如果是nil，则使用http.DefaultTransport
    Transport http.RoundTripper
    // 刷新到客户端的刷新间隔
    FlushInterval time.Duration
    // 错误记录器，用于记录错误
    ErrorLog *log.Logger
    // 顶一个一个缓冲池，在复制http响应时使用，可以提高请求效率
    BufferPool BufferPool
    // 修改response，可以返回error，来主动的触发ErrorHandler
    ModifyResponse func(*http.Response)error
    // 错误处理回调函数，如果是nil，则遇到错误会显示502.连接池的错误也会影响到ErrorHandler的调用
    ErrorHandler func(http.ResponseWriter,*http.Request)
}

    
        func NewLoadBalanceReverseProxy(c *gin.Context, lb load_balance.LoadBalance, trans *http.Transport) *httputil.ReverseProxy {
        //请求协调者
        director := func(req *http.Request) {
            nextAddr, err := lb.Get(req.URL.String())
            //todo 优化点3
            if err != nil || nextAddr=="" {
                panic("get next addr fail")
            }
            target, err := url.Parse(nextAddr)
            if err != nil {
                panic(err)
            }
            targetQuery := target.RawQuery
            req.URL.Scheme = target.Scheme
            req.URL.Host = target.Host
            req.URL.Path = singleJoiningSlash(target.Path, req.URL.Path)
            req.Host = target.Host
            if targetQuery == "" || req.URL.RawQuery == "" {
                req.URL.RawQuery = targetQuery + req.URL.RawQuery
            } else {
                req.URL.RawQuery = targetQuery + "&" + req.URL.RawQuery
            }
            if _, ok := req.Header["User-Agent"]; !ok {
                req.Header.Set("User-Agent", "user-agent")
            }
        }
    
        //更改内容
        modifyFunc := func(resp *http.Response) error {
            // 并不是所有情况都需要对response进行重写
            if strings.Contains(resp.Header.Get("Connection"), "Upgrade") {
                return nil
            }
    
            //todo 优化点2
            //var payload []byte
            //var readErr error
            //
            //if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
            //	gr, err := gzip.NewReader(resp.Body)
            //	if err != nil {
            //		return err
            //	}
            //	payload, readErr = ioutil.ReadAll(gr)
            //	resp.Header.Del("Content-Encoding")
            //} else {
            //	payload, readErr = ioutil.ReadAll(resp.Body)
            //}
            //if readErr != nil {
            //	return readErr
            //}
            //
            //c.Set("status_code", resp.StatusCode)
            //c.Set("payload", payload)
            
            //resp.Body = ioutil.NopCloser(bytes.NewBuffer(payload))
            //resp.ContentLength = int64(len(payload))
            //resp.Header.Set("Content-Length", strconv.FormatInt(int64(len(payload)), 10))
            return nil
        }
    
        //错误回调 ：关闭real_server时测试，错误回调
        //范围：transport.RoundTrip发生的错误、以及ModifyResponse发生的错误
        errFunc := func(w http.ResponseWriter, r *http.Request, err error) {
            middleware.ResponseError(c,999,err)
        }

        return &httputil.ReverseProxy{Director: director, ModifyResponse: modifyFunc, ErrorHandler: errFunc}
    }
    
    func singleJoiningSlash(a, b string) string {
        aslash := strings.HasSuffix(a, "/")
        bslash := strings.HasPrefix(b, "/")
        switch {
        case aslash && bslash:
             return a + b[1:]
        case !aslash && !bslash:
            return a + "/" + b
        }
        return a + b
    }

3、header头 Connection
    1、标记请求发起方与第一代理的状态（如果请求经过了多个代理，第一个就是第一代理，每个代理都需要转发，客户端与第一代理建立三次握手，
        第一代理一边接收，一边将接收到的消息发送到第二代理，第一代理和第二代理也需要建立socket连接，与最终服务器也需要建立socket，
        客户端不知道服务器端的ip）
    2、决定当前事务完成后，是否会关闭网络
        Connection：keep-alive不关闭网络，复用连接；浏览器请求都是这个方式
        Connection：close 关闭网络，如果是col都是这个方式
        Connection：Upgrade 协议升级，一般websocket、http2都会使用这个方式
4、TE 是request_header（请求头），表示希望使用的传输编码类型
    如：TE:trailers，deflate；q0.5，表示期望在采用分块阐述编码响应中接收挂载字段，zilb编码，0。5优先级排序
5、 Trailer是response header（返回头），允许发送方在消息后边添加额外的元信息
    如：Trailer：Expires，表示超时，Expires将出现在分块信息的结尾
    

第一代理去除标准的逐段传输头（hop-by-hop）：第一代理在转发消息的时候需要把逐段传输头去掉，因为这些消息头只标记了和第一代理之间的消息传递细节，
    再向下游传输的时候，这些头是没有用的。并且状态已经失效了
    1、逐段传输头需要在Connection中列出
    2、第一代理需要知道是去处理它，而不是去转发它（比如协议升级，客户端和第一代理之间需要，但是第一代理和第二代理就不需要了）
    3、逐段传输头有：Keep-Alive,Transfer-Encoding,TE,Connection,Trailer,Upgrade,Proxy-Authorization,Proxy-Authenticate
    

6、ReverseProxy的特殊StatusCode
    100：表示一切正常，客户端可以继续请求 continue
    101：服务端发送给客户端升级协议的请求

    
    100 ：
        1、客户端要Post的数据大于1024字节的时候
        2、客户端不会直接就发起post请求，而是会分为两步：
            a、发送一个请求，包含一个Expect：100-continue，询问Server是否愿意接收数据
            b、接收到Server返回的100-continue应答后，返回100状态，才会把数据post给Server
    101：切换协议的状态码

7、ReverseProxy的特殊Header头：ReverseProxy内部有一些关闭header头的逻辑，有助于理解http代理的实现细节
    1、X-Forwarded-For：记录每一个反向代理的ip，可能会被伪造：client_ip,proxy_ip1,proxy_ip2
    2、X-Real-IP：实际请求的ip即client_ip:每经过一层代理都会被覆盖掉，只需要在第一代理设置转发。不会被伪造
    3、Connection：这个链接是关闭还是长连接，或者升级链接
    4、TE 表示希望使用的传输编码类型
    5、Trailer允许发送方在消息后边添加额外的元信息
    
    第一代理去除标准的逐段传输头（hop-by-hop）

8、ReverseProxy源码分析
    func (p *ReverseProxy)ServeHttp: 即实现了handler接口，所以可以传到http.ListenAndServe(addr,ReverseProxy)中
    1、验证是否请求终止（例如客户突然关闭浏览器，则终止）
    2、设置请求ctx信息
    3、深拷贝header
    4、修改req
    5、Upgrde头的特殊处理
    6、追加clientIp信息
    7、向下游请求数据   
    8、处理升级协议请求
    9、移除逐段头部
    10、修改返回内容
    11、拷贝头部数据
    12、写入状态码
    13、周期性的刷新内容到response


        func (p *ReverseProxy) ServeHTTP(rw http.ResponseWriter, req *http.Request) {
            transport := p.Transport
            // 验证是否设置了连接池，如果没有就使用默认的连接池
            if transport == nil {
                transport = http.DefaultTransport
            }
            
            // 验证请求是否终止，例如关闭了浏览器
            ctx := req.Context()
            if cn, ok := rw.(http.CloseNotifier); ok {
                var cancel context.CancelFunc
                ctx, cancel = context.WithCancel(ctx)
                defer cancel()
                // 取出通知的channel
                notifyChan := cn.CloseNotify()
                go func() {
                    select {
                    case <-notifyChan:
                        // 如果接受了取消的通知，就取消这个请求
                        cancel()
                    case <-ctx.Done():
                    }
                }()
            }
        
            // 设置ctx信息：深拷贝header,将上游的header复制到下游的header中
            outreq := req.Clone(ctx)
            if req.ContentLength == 0 {
                outreq.Body = nil // Issue 16036: nil Body for http.Transport retries
            }
            if outreq.Body != nil {
                // Reading from the request body after returning from a handler is not
                // allowed, and the RoundTrip goroutine that reads the Body can outlive
                // this handler. This can lead to a crash if the handler panics (see
                // Issue 46866). Although calling Close doesn't guarantee there isn't
                // any Read in flight after the handle returns, in practice it's safe to
                // read after closing it.
                defer outreq.Body.Close()
            }
            if outreq.Header == nil {
                outreq.Header = make(http.Header) // Issue 33142: historical behavior was to always allocate
            }
        
            // 修改req 此函数可以对请求的信息进行修改 
            p.Director(outreq)
            outreq.Close = false //这条请求连接是可以被复用的
        
            // upgrade头的特殊处理
            reqUpType := upgradeType(outreq.Header)
            if !ascii.IsPrint(reqUpType) {
                p.getErrorHandler()(rw, req, fmt.Errorf("client tried to switch to invalid protocol %q", reqUpType))
                return
            }
            // 删除Connection的Headers信息
            removeConnectionHeaders(outreq.Header)
        
            // Remove hop-by-hop headers to the backend. Especially
            // important is "Connection" because we want a persistent
            // connection, regardless of what the client sent to us.
            // 删除后端的逐段header头，尤其重要的是连接，因为我们需要一个持久的连接，而不是客户端发送给我们什么
            // 逐段header头不应该发送到第二代理及之后
            for _, h := range hopHeaders {
                outreq.Header.Del(h)
            }
        
            // Issue 21096: tell backend applications that care about trailer support
            // that we support trailers. (We do, but we don't go out of our way to
            // advertise that unless the incoming client request thought it was worth
            // mentioning.) Note that we look at req.Header, not outreq.Header, since
            // the latter has passed through removeConnectionHeaders.
            if httpguts.HeaderValuesContainsToken(req.Header["Te"], "trailers") {
                outreq.Header.Set("Te", "trailers")
            }
        
            // After stripping all the hop-by-hop connection headers above, add back any
            // necessary for protocol upgrades, such as for websockets.
            // 如果upgrade不为空就设置
            if reqUpType != "" {
                outreq.Header.Set("Connection", "Upgrade")
                outreq.Header.Set("Upgrade", reqUpType)
            }
            
            // 追加client ip的信息
            if clientIP, _, err := net.SplitHostPort(req.RemoteAddr); err == nil {
                // If we aren't the first proxy retain prior
                // X-Forwarded-For information as a comma+space
                // separated list and fold multiple headers into one.
                prior, ok := outreq.Header["X-Forwarded-For"]
                omit := ok && prior == nil // Issue 38079: nil now means don't populate the header
                if len(prior) > 0 {
                    clientIP = strings.Join(prior, ", ") + ", " + clientIP
                }
                if !omit {
                    // 主要是追加X-Forwarded-For信息
                    outreq.Header.Set("X-Forwarded-For", clientIP)
                }
            }
        
            // 向下游请求的数据
            res, err := transport.RoundTrip(outreq)
            if err != nil {
                p.getErrorHandler()(rw, outreq, err)
                return
            }
            
            // 升级协议请求
            // Deal with 101 Switching Protocols responses: (WebSocket, h2c, etc)
            if res.StatusCode == http.StatusSwitchingProtocols {
                if !p.modifyResponse(rw, res, outreq) {
                    return
                }
                // 升级协议请求：比较上下游协议是否都升级成功了-》拷贝header头信息（把下游的请求header拷贝到上游）
                p.handleUpgradeResponse(rw, outreq, res)
                // 升级成功直接返回
                return
            }
        
            // 没有升级成功，需要移除逐段头部数据：要将下游返回的无用的逐段头部数据删除
            removeConnectionHeaders(res.Header)
        
            for _, h := range hopHeaders {
                res.Header.Del(h)
            }
        
            // 更改返回内容
            if !p.modifyResponse(rw, res, outreq) {
                return
            }
            
            // 拷贝头部数据 将下游的res.Header，拷贝到上游rw.Header()
            copyHeader(rw.Header(), res.Header)
        
            // The "Trailer" header isn't included in the Transport's response,
            // at least for *http.Transport. Build it up from Trailer.
            // 处理Trailer
            announcedTrailers := len(res.Trailer)
            if announcedTrailers > 0 {
                trailerKeys := make([]string, 0, len(res.Trailer))
                for k := range res.Trailer {
                    trailerKeys = append(trailerKeys, k)
                }
                rw.Header().Add("Trailer", strings.Join(trailerKeys, ", "))
            }
            
            // 写入状态码：返回给客户端的状态
            rw.WriteHeader(res.StatusCode)
        
            // 周期刷新内容到response
            err = p.copyResponse(rw, res.Body, p.flushInterval(res))
            if err != nil {
                defer res.Body.Close()
                // Since we're streaming the response, if we run into an error all we can do
                // is abort the request. Issue 23643: ReverseProxy should use ErrAbortHandler
                // on read error while copying body.
                if !shouldPanicOnCopyError(req) {
                    p.logf("suppressing panic for copyResponse error in test; copy error: %v", err)
                    return
                }
                panic(http.ErrAbortHandler)
            }
            // 读取完成后，现在可以关闭了
            res.Body.Close() // close now, instead of defer, to populate res.Trailer
        
            // trailer逻辑处理
            if len(res.Trailer) > 0 {
                // Force chunking if we saw a response trailer.
                // This prevents net/http from calculating the length for short
                // bodies and adding a Content-Length.
                if fl, ok := rw.(http.Flusher); ok {
                    fl.Flush()
                }
            }
        
            if len(res.Trailer) == announcedTrailers {
                copyHeader(rw.Header(), res.Trailer)
                return
            }
        
            for k, vv := range res.Trailer {
                k = http.TrailerPrefix + k
                for _, v := range vv {
                    rw.Header().Add(k, v)
                }
            }
        }

    
    
[在反向代理中加入负载均衡] proxy/load_balance/factory.go

---

[HTTP代理进阶]
1、 中间件
