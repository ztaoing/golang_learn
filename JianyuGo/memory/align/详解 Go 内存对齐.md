【前情概要】

在了解内存对齐之前，先来明确几个关于操作系统的概念，更加方面我们对内存对齐的理解。

[内存管理]:

我们都知道内存是计算中重要的组成之一，内存是与CPU进行沟通的桥梁，
用于暂存CPU中的运算数据、以及与硬盘等外部存储器交换的数据。

早期，程序是直接运行在物理内存上的，直接操作物理内存，但是会存在一些问题，
比如使用效率低、地址空间不隔离等问题，所以就出现了虚拟内存，

虚拟内存就是在程序和物理内存之间引入了一个中间层，这个中间层就是虚拟内存，
这样就达到了对进程地址和物理地址的隔离。

在linux系统中，将虚拟内存划分为用户空间和内核空间，用户进程只能访问用户空间的虚拟地址，

只有通过系统调用、外设中断或异常才能访问内核空间，

我们主要来看一下用户空间，用户空间被分为5个不同内存区域：

高地址--》低地址

stack-》heap-》BSS-》数据段-》代码段

* 代码段：存放可执行文件的操作指令，只读
* 数据段：用来存放可执行文件中已初始化全局变量，存放静态变量和全局变量
* BSS段：用来存未初始化的全局变量
* 栈区：用来存临时创建的局部变量
* 堆区：用来存动态分配的内存段


[CPU]

中央处理单元（Cntral Pocessing Unit）的缩写，也叫处理器；CPU是计算机的运算核心和控制核心，
我们人类靠着大脑思考，电脑就是靠着CPU来运算、控制，起到协调和控制作用，

从功能来看，CPU 的内部由寄存器、控制器、运算器和时钟四部分组成，各部分之间通过电信号连通。

[CPU和内存的工作关系]

当我们执行一个程序时，首先由输入设备向CPU发出操作指令，CPU接收到操作指令后，
硬盘中对应的程序就会被直接加载到内存中，

此后，CPU 再对内存进行寻址操作，将加载到内存中的指令翻译出来，
而后发送操作信号给操作控制器，实现程序的运行或数据的处理。

存在于内存中的目的就是为了CPU能够过总线进行寻址，取指令、译码、执行取数据，内存与寄存器交互，然后CPU运算，再输出数据至内存。
[os]

os全称为Operating System，也就是操作操作系统，
是一组主管并控制计算机操作、运用和运行硬件、软件资源和提供公共服务组织用户交互的相互关联的系统软件，
同时也是计算机系统的内核与基石。

[编译器]

编译器就是将“一种语言（通常为高级语言）”翻译为“另一种语言（通常为低级语言）”的程序。

一个现代编译器的主要工作流程：

源代码 (source code) → 预处理器(preprocessor) → 编译器 (compiler) → 目标代码 (object code) → 链接器 (Linker) → 可执行程序(executables)。


[写在最后的一个知识点]：

计算机中，最小的存储单元为字节，理论上任意地址都可以通过总线进行访问，每次寻址能传输的数据大小就跟CPU位数有关。
常见的CPU位数有8位，16位，32位，64位。

位数越高，单次操作执行的数据量越大，性能也就越强。

os的位数一般与CPU的位数相匹配，32位CPU可以寻址4GB内存空间，也可以运行32位的os，
同样道理，64位的CPU可以运行32位的os，也可以运行64位的os。

---

[何为内存对齐]

现代计算机中内存空间都是按照字节(byte)进行划分的，所以从理论上讲对于任何类型的变量访问都可以从任意地址开始，
但是在实际情况中，在访问特定类型变量的时候经常在特定的内存地址访问，
所以这就需要把各种类型数据按照一定的规则在空间上排列，而不是按照顺序一个接一个的排放，
这种就称为内存对齐，内存对齐是指首地址对齐，而不是说每个变量大小对齐。

[为何要有内存对齐]
主要原因可以归结为两点：

* 有些CPU可以访问任意地址上的任意数据，而有些CPU只能在特定地址访问数据，
  因此不同硬件平台具有差异性，这样的代码就不具有移植性，
  
  如果在编译时，将分配的内存进行对齐，这就具有平台可以移植性了
  
* CPU每次寻址都是要消费时间的，
  并且CPU 访问内存时，并不是逐个字节访问，
  而是以字长（word size）为单位访问，
  所以数据结构应该尽可能地在自然边界上对齐，
  如果访问未对齐的内存，处理器需要做两次内存访问，
  而对齐的内存访问仅需要一次访问，内存对齐后可以提升性能。举个例子：

假设当前CPU是32位的，并且没有内存对齐机制，数据可以任意存放，

现在有一个int32变量占4byte，存放地址在0x00000002 - 0x00000005(纯假设地址，莫当真)，
这种情况下，每次取4字节的CPU第一次取到[0x00000000 - 0x00000003]，只得到变量1/2的数据，

所以还需要取第二次，为了得到一个int32类型的变量，需要访问两次内存并做拼接处理，影响性能。

如果有内存对齐了，int32类型数据就会按照对齐规则在内存中，上面这个例子就会存在地址0x00000000处开始
，那么处理器在取数据时一次性就能将数据读出来了，而且不需要做额外的操作，使用空间换时间，提高了效率。

---

[对齐系数]