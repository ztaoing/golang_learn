/**
* @Author:zhoutao
* @Date:2022/3/1 08:59
* @Desc:
 */

package _8tree

//剑指 Offer 28. 对称的二叉树
// 请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。
//例如，二叉树 [1,2,2,3,4,4,3] 是对称的。

// 04.05. 合法二叉搜索树
//递归调用  时间复杂度O（N）
//空间复杂度O（N）递归函数在递归过程中需要为每一层递归函数分配栈空间，所以这里需要额外的空间且该空间取决于递归的深度，即二叉树的高度

//在二叉搜索树中查找一个数字

//在二叉搜索树中插入一个数

//在二叉搜索树中删除一个数

//计算普通二叉树的节点数

//计算满二叉树的节点数

//计算完全二叉树的节点数：完全二叉树：每一层都是紧凑向左排列

/**
用各种遍历框架序列化和反序列化二叉树
*/

//剑指 Offer 07. 重建二叉树

//剑指 Offer 68 - II. 二叉树的最近公共祖先

//111. 二叉树的最小深度
//深度优先搜索
//广度优先搜索:最先到达的叶子节点就是最小深度:即找到叶子节点

//剑指 Offer 33. 二叉搜索树的后序遍历序列:
//输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。
